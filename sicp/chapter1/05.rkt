#lang sicp

; TASK:

#| Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком |#
#| вычислений онработает, аппликативным или нормальным. Бен определяет такие две |#
#| процедуры: |#

(define (p) (p))

(define (test x y)
    (if (= x 0)
        0
        y))

#| Затем он вычисляет выражение |#

(test 0 (p))

#| Какое поведение увидит Бен, если интерпретатор использует аппликативный |#
#| порядок вычислений? Какое поведение он увидит, если интерпретатор использует |#
#| нормальный порядок? Объясните Ваш ответ. |#
#| (Предполагается, что правило вычисления особой формы if одинаково независимо |#
#| от того,какой порядок вычислений используется. Сначала вычисляется |#
#| выражение-предикат, и результат определяет, нужно ли вычислять выражение-следствие |#
#| или альтернативу.) |#


; SOLUTION:

#| Функция (p) рекурсивно вызывает сама себя до бесконечности, что подвешивает
интерпретатор. |#
#| В случае аппликативного интерпретатора, операция test будет развёрнута до
раскрытия её операндов, и они не будут вычисляться пока не потребуются их значения.
Поэтому сначала мы попадём в if, где потребуется значение `x`, и после подстановки
попадём в ветку следствия, которая вернёт нам  `0`. Ветка альтернативы же, для
которой нам потребуется раскрытие операнда (p) — нам не потребуется. |#
#| В случае с нормальным порядком вычислений интерпретатор сначала попытается
раскрыть операнд (p), что вызовет бесконечную рекурсию и подвесит |#
