#lang sicp

(#%require rackunit)

; TASK:
;
; Наименьшие простые числа
;
; Большая часть реализаций Лиспа содержат элементарную процедуру runtime
; , которая возвращает целое число, показывающее, как долго работала система
; (например, в миллисекундах). Следующая процедура timed-prime-test , будучи
; вызвана с целым числом n , печатает n и проверяет, простое ли оно. Если
; n простое, процедура печатает три звездочки и количество времени, затраченное
; на проверку.

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

; Используя эту процедуру, напишите процедуру
; search-for-primes , которая проверяет на простоту все
; нечетные числа в заданном диапазоне.
; С помощью этой процедуры найдите наименьшие три простых числа:
; — после 1000;
; — после 10 000;
; — после 100 000;
; — после 1 000 000.
; Посмотрите, сколько времени затрачивается на каждое простое число.
; Поскольку алгоритм проверки имеет порядок роста Θ(√n), Вам следовало бы
; ожидать, что проверка на простоту чисел, близких к 10 000,
; занимает в √10 раз больше времени, чем для чисел, близких к 1000.
; Подтверждают ли это Ваши замеры времени?
; Хорошо ли поддерживают предсказание √n данные для 100 000 и 1 000 000?
;
; Совместим ли Ваш результат с предположением, что программы на Вашей машине
; затрачивают на выполнение задач время, пропорциональное числу шагов?


; SOLUTION:

(define (search-for-primes a b)
  (define (iter num)
    (timed-prime-test num)
    (if (not (> num b)) (iter (+ num 1))))
  (iter a))

; Простые числа после 1000:  1009, 1013, 1019
; Простые числа после 10000: 10007, 10009, 10037
; Простые числа после 100000:  100003, 100019, 100043
; Простые числа после 1000000:  1000003, 1000033, 1000037

; Да, замеры времени подтверждают скорость работы алгоритма





; HELPERS:

(define (prime? n)
  (= n (smallest-divisor n)))

(define (smallest-divisor n)
  (define (find-divisor test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor (+ test-divisor 1)))))
  (find-divisor 2))

(define (square x) (* x x))

(define (divides? a b)
  (= (remainder b a) 0))
