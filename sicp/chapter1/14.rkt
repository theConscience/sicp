#lang sicp
(#%require rackunit)

; TASK:
; Размен 11 центов
; Нарисуйте дерево, иллюстрирующее процесс, который порождается процедурой
; count-change из раздела 1.2.2 при размене 11 центов. Каковы порядки роста
; памяти и числа шагов, используемых этим процессом при увеличении суммы,
; которую требуется разменять?

(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))


; SOLUTION:
(count-change 11)
; (cc 11 5)
;
; #1 iteration:
;
; (cond ((= 11 0) 1)                -> #f
;       ((or (< 11 0) (= 5 0)) 0)   -> #f
;       (else (+ (cc 11             -> #t раскрываем эту ветвь:
;                    (- 5 1))
;                (cc (- 11
;                    (first-denomination 5))
;                    5))))
;
; Ветка else преобразуется:
; (+ (cc 11 4) (cc (- 11 (first-denomination 5)) 5))
; (+ (cc 11 4) (cc (- 11 50) 5))
; (+ (cc 11 4) (cc -39 5))
; (+ (+ (cc 11 3) (cc (- 11 (first-denomination 4)) 4)) (cc -39 5))
; (+ (+ (cc 11 3) (cc (- 11 25) 4)) (cc -39 5))
; (+ (+ (cc 11 3) (cc -14 4)) (cc -39 5))
; (+ (+ (+ (cc 11 2) (cc (- 11 10) 3)) (cc -14 4)) (cc -39 5))
; (+ (+ (+ (cc 11 2) (cc 1 3)) (cc -14 4)) (cc -39 5))
; (+ (+ (+ (+ (cc 11 1) (cc 6 2)) (cc 1 3)) (cc -14 4)) (cc -39 5))
; (+ (+ (+ (+ (+ (cc 11 0) (cc 9 1)) (cc 6 2)) (cc 1 3)) (cc -14 4)) (cc -39 5))
; (+ (+ (+ (+ (+ 0 (cc 9 1)) (cc 6 2)) (cc 1 3)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ (cc 9 0) (cc 8 1))) (+ (cc 6 1) (cc 1 2))) (+ (cc 1 2) (cc -9 3))) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ (cc 8 0) (cc 7 1)))) (+ (+ (cc 6 0) (cc 5 1)) (+ (cc 1 1) (cc -4 2)))) (+ (+ (cc 1 1) (cc -4 2)) 0)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (cc 7 1)))) (+ (+ 0 (cc 5 1)) (+ (cc 1 1) 0))) (+ (+ (cc 1 1) 0) 0)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (cc 7 1)))) (+ (+ 0 (cc 5 1)) (+ 1 0))) (+ (+ 1 0) 0)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (cc 7 1)))) (+ (+ 0 (cc 5 1)) (+ 1 0))) (+ (+ 1 0) 0)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ (cc 7 0) (cc 6 1))))) (+ (+ 0 (+ (cc 5 0) (cc 4 1))) (+ 1 0))) (+ (+ 1 0) 0)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (cc 6 1))))) (+ (+ 0 (+ 0 (cc 4 1))) (+ 1 0))) (+ (+ 1 0) 0)) 0) 0)
; Далее понятно, что (cc 6 1) и (cc 4 1) будут сокращаться аналогично, пока не дойдет до
; (+ 1 0), поэтому упрощаю все аналогичные выражения:
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 1 0))))) (+ (+ 0 (+ 0 (+ 1 0))) (+ 1 0))) (+ (+ 1 0) 0)) 0) 0)
; (+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 1)))) (+ (+ 0 (+ 0 1)) 1)) (+ 1 0)) 0) 0)
; получается 4 единицы, поэтому ответ — 4
; 4
;
; Теперь попробуем увеличить сумму в 2 раза:
(count-change 22)
; (cc 22 5)
;
; Ветка с else преобразуется:
; (+ (cc 22 4) (cc (- 22 50) 5))
; (+ (cc 22 4) (cc -28 5))
; (+ (cc 22 4) 0)
; (cc 22 4)
; (+ (cc 22 3) (cc (- 22 25) 4))
; (+ (cc 22 3) (cc -3 4))
; (+ (cc 22 3) 0)
; (cc 22 3)
; (+ (cc 22 2) (cc (- 22 10) 3))
; (+ (cc 22 2) (cc 12 3))
; (+ (+ (cc 22 1) (cc (- 22 5) 2)) (+ (cc 12 2) (cc (- 12 10) 3)))
; (+ (+ (cc 22 1) (cc 17 2)) (+ (cc 12 2) (cc 2 3)))


; TESTS:

#| (check-equal? (f 5) 25) |#
#| (check-equal? (f-iter 4) 11) |#
#| (check-equal? (f 3) 4) |#
#| (check-equal? (f-iter 1) 1) |#
